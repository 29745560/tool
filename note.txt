JavaScript学习笔记


8.判断一个对象是否是window对象

  由于window的特殊性（globel），所以，判断它用的方法也很特殊
  
  如果一个对象是window对象,那么其下有一个window属性，就是它本身
  
  return obj!= null && obj == obj.window
  
  

7.数组复制
 
   如 var arr = [1,2,3,4]
   a. var arr2 = arr.slice(0)
   b. var arr2 = arr.concat()

6.likeArray转Array

  如 var likeArray = {0:0,1:1,2:2,length:3}
   a.var arr = Array.prototype.slice.call(likeArray)
   b.var arr = [].slice.call(likeArray)

5.在函数内部定义与函数重名的变量

 a.
   function test(){
     alert(test)
   }
   test() // function test(){ alert(test) }
   test() // function test(){ alert(test) }
 b.
   function test(){
     var test = 2;
     alert(test);
   }
   test() // 2
   test() // 2
 c.
   function test(){
     test = 2;
     alert(test);
   }
   test() // 2
   test() // 报错。因为此时全局下的test已经变为2，并不是一个函数了。Uncaught TypeError: test is not a function
   
  结论：在函数内部定义跟函数名一致的变量要注意，一定使用var来使得同函数名的变量变为局部变量。。
  否则，定义的函数只有第一次执行时是正确的，后续的调用会出问题 xxx is not a function
 
4.
  var name = 'liyanfeng';
  (function(){
    alert(name); // liyanfeng
  })()
  相当于
  var name = 'liyanfeng';
  function any(){
    alert(name);
  }
  any(); // liyanfeng
  

3. NaN === NaN  --> false
  
   在js中只有NaN不等于自己，可以利用这个特性来判断一个字符串是否是数字

   如
 
   var str = '123';

   str = +str;

   if(str === str){
  
       // 说明不是NaN，也就是说 使用 + 号进行类型转换并没有问题，所以str肯定是数字格式的字符串
       
   }

2.可以把一个构造函数当成一个普通函数来执行

  var Person = function(){
    this.name = 'liyanfeng';
    this.age = 24;
    console.log('person constructor');
    return 123;
  }
 
  var p = new Person(); // is a new object not a number 123
  
  var p2 = p.constructor(); // is a number 123 not a new object
 

1.带返回值的构造函数

  
  function return123(){
    
      console.log('return123 execute...');     
    
      return 123;
  
  }
  
  
  
  var Person = function(name,age){
    
     this.name = name;
     
     this.age = age;
     
     return return123();

  }

  var p = Person('liyanfeng',24);
  
  // 首先打印出 return123 execute...
 
  console.log(p) // 123
  
  console.log(p.name) // undefined
 
  console.log(p.age) // undefined
 
  name 和 age 绑定到了全局环境中。。


  var Person = function(name,age){
    
     this.name = name;
     
     this.age = age;
     
     return return123();

  }

  var p2 = new Person('liyanfeng',24);
  
  // 首先打印出 return123 execute...
 
  console.log(p2) // Person {name: "liyanfeng", age: 24}
  
  console.log(p2.name) // liyanfeng
 
  console.log(p2.age) // 24


  可以看出来，若是前面有new操作符，return后的语句虽然会执行，但是忽略掉了返回值，因为js引擎要把new出的对象的应用赋值给p2。。。p2并不能接收2个返回值。。。！！！！！


  





